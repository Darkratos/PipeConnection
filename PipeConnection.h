#pragma once

/*
These are the defines for the operations and errors
*/

#define PIPE_READ 0
#define PIPE_WRITE 1

#define PIPE_NO_ERROR -1
#define PIPE_READ_ERROR 1
#define PIPE_WRITE_ERROR 2
#define PIPE_CREATE_ERROR 3
#define PIPE_CONNECT_ERROR 4

#define BUFSIZE 1024*1024*10

class cPipe
{
public:
	/*
	Creates a named pipe with IN/OUT permissions

	@Return Value: returns true if the creation is successful
	*/
	bool create( std::string pipe_name );

	/*
	Connects to a named pipe with RW permissions

	@Return Value: returns true if the connection is successful
	*/
	bool connect( std::string pipe_name );

	/*
	Disconnects from a named pipe
	This has to be called after a connection is done, otherwise the function will return false
	*/
	bool disconnect( void );

	/*
	@Return Value: returns the last error generated by the class
	After it's called, the last error is automatically set to PIPE_NO_ERROR
	*/
	int get_last_error( void );

	/*
	Writes a message at the pipe
	The function will wait until the operation is completed or an error occours
	If the function fails, last_error is set to PIPE_WRITE_ERROR
	*/
	void write( std::string message );

	/*
	Reads the message from the pipe
	Use get_message() to retrieve it's contents
	The function will wait until there is a text to read or an error
	If the function fails, last_error is set to PIPE_READ_ERROR
	*/
	void read( void );

	/*
	Retrieves the saved message from the buffer after calling read()
	After this function is called, the text holder will be empty
	*/
	std::string get_message( void );

	/*
	Retrieves the handle of the pipe
	*/
	HANDLE get_pipe_handle( void );

	/*
	Retrieves the handle of the thread
	*/
	HANDLE get_thread_handle( void );

	/*
	Functions used by the thread
	Should not be used by the user
	*/
	bool can_write( void );
	bool can_read( void );
	void clear_write( void );
	void clear_read( void );
	void set_message( std::string message );
	std::string get_write_message( void );
	void set_last_error( int error );

	OVERLAPPED ov;
private:
	std::string write_buffer;
	std::string read_buffer;

	std::string pipe_final_name = "\\\\.\\pipe\\";

	HANDLE pipe_handle = INVALID_HANDLE_VALUE;
	HANDLE thread_handle = 0;
	DWORD thread_id;

	int last_error = -1;

	bool read_flag = false;
	bool write_flag = false;
	bool created_pipe = false;

	bool has_text = false;
	bool finished_writing = false;

	static DWORD WINAPI pipe_thread( LPVOID param );
};
